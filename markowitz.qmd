---
title: "Modelo de Markowitz"
format: 
  html:
    css: styles_markowitz.css   # CSS exclusivo para este arquivo 
execute:
  echo: false
---

## üìä Otimiza√ß√£o de Carteira 


### üìà O que √©?
O modelo de Markowitz, tamb√©m chamado de Teoria Moderna de Portf√≥lios, busca construir uma carteira de ativos que ofere√ßa o melhor equil√≠brio poss√≠vel entre risco e retorno.

### ‚öôÔ∏è Como funciona o modelo?
#### Entradas principais:

üî∏ Retorno esperado de cada ativo

üî∏ Matriz de covari√¢ncia dos retornos (risco e correla√ß√£o entre os ativos)

O objetivo do modelo √©: Minimizar a volatilidade (risco) da carteira

#### Sujeito a:

‚úÖ O retorno da carteira ser igual a um alvo (target_return)

‚úÖ A soma dos pesos ser igual a 1 (100% do capital investido)

‚úÖ (Opcional) Pesos ‚â• 0 ‚Üí n√£o permite venda a descoberto (short)



```{r , include=FALSE}
```{r , include=FALSE}
# üì¶ Pacotes
library(tidyquant)
library(tidyverse)
library(quadprog)
library(PerformanceAnalytics)

# üîó Tickers
tickers <- c("F", "GM", "HMC", "STLA", "TM")

# ‚è≥ Pegar dados dos √∫ltimos 2 anos
dados <- tq_get(tickers,
                from = Sys.Date() - 365*2,
                to = Sys.Date(),
                get = "stock.prices")

# üìà Retornos logar√≠tmicos di√°rios
retornos <- dados %>%
  group_by(symbol) %>%
  tq_transmute(select = adjusted,
               mutate_fun = periodReturn,
               period = "daily",
               type = "log",
               col_rename = "retorno") %>%
  pivot_wider(names_from = symbol, values_from = retorno) %>%
  drop_na()

matriz_retorno <- as.matrix(retornos[,-1])
cov_mat <- cov(matriz_retorno)
mean_returns <- colMeans(matriz_retorno)
n_assets <- ncol(matriz_retorno)

# üîß Modelo de Markowitz
Dmat <- 2 * cov_mat
dvec <- rep(0, n_assets)

# üî¢ Restri√ß√µes: soma dos pesos = 1, retorno = alvo, pesos ‚â• 5%
peso_min <- 0.05
peso_max <- 1 - (n_assets - 1) * peso_min

# Calcular retorno m√≠nimo e m√°ximo vi√°vel dados os limites
retorno_min_viavel <- sum(rep(peso_min, n_assets) * mean_returns)
retorno_max_viavel <- sum(sort(mean_returns, decreasing = TRUE)[1] * peso_max +
                          sum(sort(mean_returns, decreasing = TRUE)[-1] * peso_min))

# üîç Definir retorno alvo automaticamente dentro do intervalo
target_return <- (retorno_min_viavel + retorno_max_viavel) / 2

cat("üìâ Retorno m√≠nimo vi√°vel (com 5% por ativo):", round(retorno_min_viavel, 6), "\n")
cat("üìà Retorno m√°ximo vi√°vel (com 5% por ativo):", round(retorno_max_viavel, 6), "\n")
cat("üéØ Retorno alvo definido automaticamente:", round(target_return, 6), "\n")

# üöß Matriz de restri√ß√µes
Amat <- cbind(
  rep(1, n_assets),       # soma dos pesos = 1
  mean_returns,           # retorno alvo
  diag(1, n_assets)       # pesos ‚â• peso_min
)

bvec <- c(1, target_return, rep(peso_min, n_assets))

# ‚ö†Ô∏è Resolver otimiza√ß√£o
sol <- solve.QP(Dmat, dvec, Amat, bvec, meq = 2)

# üéØ Pesos √≥timos
pesos_otimos <- sol$solution
nomes_ativos <- colnames(matriz_retorno)

resultado_pesos <- tibble(
  Acao = nomes_ativos,
  Peso = round(pesos_otimos, 4)
)

resultado_pesos



```

```{r}
# Plotar os pesos com a mesma cor de fundo do documento
resultado_pesos %>%
  ggplot(aes(x = reorder(Acao, Peso), y = Peso, fill = Acao)) +
  geom_col(alpha = 0.9, width = 0.7) +
  coord_flip() +
  scale_y_continuous(labels = scales::percent, 
                     expand = expansion(mult = c(0, 0.05))) +
  scale_fill_viridis_d(option = "plasma", begin = 0.2, end = 0.9) +
  labs(title = "Pesos √ìtimos da Carteira",
       subtitle = "Distribui√ß√£o percentual por a√ß√£o",
       x = "A√ß√£o",
       y = "Peso (%)",
       fill = "A√ß√£o") +
  theme_void() +
  theme(
    # Fundo igual ao documento (#1a1a1a)
    plot.background = element_rect(fill = "#1a1a1a", color = NA),
    panel.background = element_rect(fill = "#1a1a1a", color = NA),
    
    # Texto branco para contraste
    text = element_text(color = "white"),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5, 
                              margin = margin(b = 10), color = "white"),
    plot.subtitle = element_text(size = 12, hjust = 0.5, 
                                 margin = margin(b = 20), color = "grey80"),
    
    # Eixos
    axis.text.x = element_text(size = 11, color = "white"),
    axis.text.y = element_text(size = 11, color = "white"),
    axis.title.x = element_text(size = 12, margin = margin(t = 15), color = "white"),
    axis.title.y = element_text(size = 12, margin = margin(r = 15), color = "white"),
    
    # Grid sutil
    panel.grid.major.x = element_line(color = "grey40", linewidth = 0.3),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    
    # Legenda
    legend.background = element_rect(fill = "#1a1a1a", color = NA),
    legend.text = element_text(color = "white", size = 10),
    legend.title = element_text(color = "white", size = 11, face = "bold"),
    legend.key = element_rect(fill = "#1a1a1a", color = NA),
    legend.position = "right",
    legend.margin = margin(l = 20),
    
    # Margens
    plot.margin = margin(20, 20, 20, 20)
  )

```

```{r , include=FALSE}

# Pacotes
library(tidyquant)
library(dplyr)
library(ggplot2)
library(tidyr)

# üîó A√ß√µes da carteira (excluindo STLA)
tickers <- c("F", "GM", "HMC", "TM")

# üìÖ Per√≠odo hist√≥rico
dados <- tq_get(tickers,
                from = "2020-01-01",
                to = Sys.Date(),
                get = "stock.prices")

# üìà Calcular retornos di√°rios
retornos <- dados %>%
  group_by(symbol) %>%
  tq_transmute(select = adjusted,
               mutate_fun = periodReturn,
               period = "daily",
               col_rename = "retorno")

# üéØ Calcular m√©tricas de cada a√ß√£o
metricas_acao <- retornos %>%
  group_by(symbol) %>%
  summarise(
    retorno_medio = mean(retorno),
    volatilidade = sd(retorno),
    sharpe_simples = retorno_medio / volatilidade
  )

# üëá Criar os 3 cen√°rios: pessimista, realista, otimista
cenarios <- metricas_acao %>%
  mutate(
    retorno_pessimista = retorno_medio - volatilidade,
    retorno_realista = retorno_medio,
    retorno_otimista = retorno_medio + volatilidade
  ) %>%
  select(symbol, starts_with("retorno"), volatilidade, sharpe_simples)

print(cenarios)


```

```{r}

# üì¶ Pacotes
library(tidyquant)
library(dplyr)
library(gt)

# üîó A√ß√µes da carteira (exceto STLA que tem peso zero)
tickers <- c("F", "GM", "HMC", "TM","STLA")

# üìÖ Dados de pre√ßo
dados <- tq_get(tickers,
                from = "2020-01-01",
                to = Sys.Date(),
                get = "stock.prices")

# üìà Calcular retornos di√°rios
retornos <- dados %>%
  group_by(symbol) %>%
  tq_transmute(select = adjusted,
               mutate_fun = periodReturn,
               period = "daily",
               col_rename = "retorno")

# üéØ Calcular retorno m√©dio e volatilidade di√°ria
metricas <- retornos %>%
  group_by(symbol) %>%
  summarise(
    retorno_diario = mean(retorno, na.rm = TRUE),
    volatilidade_diaria = sd(retorno, na.rm = TRUE)
  ) %>%
  mutate(
    retorno_mensal = retorno_diario * 21,
    volatilidade_mensal = volatilidade_diaria * sqrt(21),
    
    retorno_anual = retorno_diario * 252,
    volatilidade_anual = volatilidade_diaria * sqrt(252),
    
    retorno_5anos = retorno_anual * 5,
    volatilidade_5anos = volatilidade_anual * sqrt(5)
  )

# üí∞ Simular cen√°rios para cada horizonte
investimento <- 1000

cenarios <- metricas %>%
  mutate(
    # Mensal
    pess_mensal = investimento * (1 + (retorno_mensal - volatilidade_mensal)),
    real_mensal = investimento * (1 + retorno_mensal),
    otim_mensal = investimento * (1 + (retorno_mensal + volatilidade_mensal)),
    
    # Anual
    pess_anual = investimento * (1 + (retorno_anual - volatilidade_anual)),
    real_anual = investimento * (1 + retorno_anual),
    otim_anual = investimento * (1 + (retorno_anual + volatilidade_anual)),
    
    # 5 anos
    pess_5anos = investimento * (1 + (retorno_5anos - volatilidade_5anos)),
    real_5anos = investimento * (1 + retorno_5anos),
    otim_5anos = investimento * (1 + (retorno_5anos + volatilidade_5anos))
  ) %>%
  select(symbol,
         pess_mensal, real_mensal, otim_mensal,
         pess_anual, real_anual, otim_anual,
         pess_5anos, real_5anos, otim_5anos)


```

```{r}

# TABELA MENSAL
tabela_mensal <- cenarios %>%
  select(symbol, pess_mensal, real_mensal, otim_mensal) %>%
  gt() %>%
  tab_header(
    title = md("**Simula√ß√£o de Retorno Mensal (21 dias √∫teis)**"),
    subtitle = "Investindo US$1.000 por a√ß√£o"
  ) %>%
  fmt_currency(
    columns = 2:4,
    currency = "USD"
  ) %>%
  cols_label(
    symbol = "A√ß√£o",
    pess_mensal = "üîª Pessimista",
    real_mensal = "üî∏ Realista",
    otim_mensal = "üî∫ Otimista"
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white")
    ),
    locations = cells_body()
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "black"),
      cell_text(color = "white", weight = "bold")
    ),
    locations = list(
      cells_column_labels(everything()),
      cells_title(groups = "title"),
      cells_title(groups = "subtitle")
    )
  ) %>%
  opt_table_font(
    font = list(gt::google_font("Roboto Mono"))
  )

tabela_mensal


```

### ‚ö†Ô∏è Por que algumas a√ß√µes ficaram com peso baixo no meu modelo de Markowitz?
No nosso Modelo de Markowitz, o objetivo √© encontrar a carteira de investimentos que ofere√ßa o melhor equil√≠brio entre risco e retorno. Quando uma a√ß√£o como a STLA (ou qualquer outra) termina com um peso baixo ou at√© zero, isso significa que o algoritmo, com base nas caracter√≠sticas estat√≠sticas dos ativos, entendeu que inclu√≠-la em maior propor√ß√£o n√£o contribuiria para otimizar o portf√≥lio. As raz√µes comuns para isso s√£o:

‚úîÔ∏è 1. Retorno Ajustado ao Risco Desfavor√°vel: A a√ß√£o possui um retorno esperado que, quando comparado ao n√≠vel de risco que ela adiciona √† carteira, n√£o √© considerado eficiente em rela√ß√£o √†s outras a√ß√µes dispon√≠veis.

‚úîÔ∏è 2. Alta Correla√ß√£o com Outros Ativos: Se a a√ß√£o tem uma correla√ß√£o muito forte com outras a√ß√µes j√° presentes na carteira (por exemplo, com GM ou TM), o modelo pode preferir os ativos que oferecem uma combina√ß√£o de retorno e risco mais vantajosa, sem a necessidade de replicar a exposi√ß√£o ao risco.

‚úîÔ∏è 3. Solu√ß√£o de Canto (Corner Solution): Em otimiza√ß√µes que imp√µem restri√ß√µes de peso m√≠nimo (como peso ‚â• 0, que impede vendas a descoberto), √© comum que alguns ativos sejam completamente removidos da carteira (peso zero). Isso ocorre porque, para atingir o retorno desejado da forma mais eficiente poss√≠vel, esses ativos n√£o s√£o essenciais ou podem at√© prejudicar a otimiza√ß√£o.

### üìä Analogia Simples:
Imagine que estamos montando um time de futebol ideal. Se temos dois jogadores que desempenham a mesma fun√ß√£o e um deles entrega um desempenho superior com menor custo (risco), escolher√≠amos apenas o melhor. O modelo de Markowitz faz exatamente isso, mas com o "desempenho" sendo o retorno e o "custo" sendo o risco da a√ß√£o.

### üî• Conclus√£o Pr√°tica:
√â importante ressaltar que o modelo n√£o est√° dizendo que uma a√ß√£o com peso baixo √© "ruim" isoladamente.

Ele simplesmente indica que, para o retorno desejado e considerando as caracter√≠sticas estat√≠sticas (volatilidade e correla√ß√£o) de todos os ativos, essa a√ß√£o espec√≠fica n√£o contribui para melhorar a carteira no ponto √≥timo que foi calculado. Se os par√¢metros da otimiza√ß√£o forem alterados (como o retorno-alvo ou a permiss√£o para vendas a descoberto), a contribui√ß√£o e o peso dessa a√ß√£o na carteira podem mudar significativamente.